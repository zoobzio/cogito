---
title: "Core Concepts"
description: "Understanding Thought, Note, and Memory in cogito"
author: "zoobzio"
published: 2024-12-01
updated: 2025-01-11
tags: [cogito, concepts, thought, note, memory]
---

# Core Concepts

cogito is built around three core concepts: Thought, Note, and Memory.

## Thought

A Thought represents the rolling context of a reasoning chain. It maintains:

- An append-only log of Notes
- A tracking cursor for published vs unpublished Notes
- An LLM session for conversation continuity
- A reference to Memory for persistence

```go
// Create a thought
thought, err := cogito.New(ctx, memory, "analyse document")

// Thoughts have identity
fmt.Println(thought.ID)       // Database-assigned UUID
fmt.Println(thought.TraceID)  // Auto-generated trace ID
fmt.Println(thought.Intent)   // "analyse document"
```

### Thought Lifecycle

1. **Creation** - `New()` creates and persists a thought
2. **Note Accumulation** - Primitives add notes via `SetContent()`
3. **Processing** - Primitives read context from notes, call LLM, write results
4. **Publication** - Notes are marked as "published" after being sent to LLM

### Cloning for Parallel Processing

Thoughts can be cloned for parallel execution:

```go
clone := thought.Clone()
// Clone has independent notes and session
// Modifications don't affect the original
```

## Note

Notes are atomic units of information in the reasoning chain:

```go
type Note struct {
    ID        string            // Database ID
    ThoughtID string            // Parent thought
    Key       string            // Lookup key
    Content   string            // String content (everything is text in LLM space)
    Metadata  map[string]string // Structured extension
    Source    string            // Origin primitive
    Created   time.Time         // Timestamp
    Embedding Vector            // Optional vector for semantic search
}
```

### Adding Notes

```go
// Simple content
thought.SetContent(ctx, "summary", "Customer requests refund", "analyze")

// With metadata
thought.SetNote(ctx, "decision", "approved", "decide", map[string]string{
    "confidence": "0.95",
    "reasoning":  "Clear policy violation",
})
```

### Reading Notes

```go
// Get content by key
content, err := thought.GetContent("summary")

// Get full note
note, ok := thought.GetNote("decision")
if ok {
    fmt.Println(note.Metadata["confidence"])
}

// Get all notes
notes := thought.AllNotes()
```

### Published vs Unpublished

Notes track whether they've been sent to the LLM:

```go
// Get notes not yet sent to LLM
unpublished := thought.GetUnpublishedNotes()

// After processing, mark as published
thought.MarkNotesPublished()
```

This prevents redundant context in multi-step pipelines.

## Memory

Memory provides persistence and semantic search:

```go
type Memory interface {
    // Thought CRUD
    CreateThought(ctx context.Context, thought *Thought) (*Thought, error)
    GetThought(ctx context.Context, id string) (*Thought, error)
    GetThoughtByTraceID(ctx context.Context, traceID string) (*Thought, error)
    UpdateThought(ctx context.Context, thought *Thought) error
    DeleteThought(ctx context.Context, id string) error

    // Note operations
    AddNote(ctx context.Context, note *Note) (*Note, error)
    GetNotes(ctx context.Context, thoughtID string) ([]Note, error)

    // Semantic search
    SearchNotes(ctx context.Context, embedding Vector, limit int) ([]NoteWithThought, error)
    SearchNotesByTask(ctx context.Context, embedding Vector, limit int) ([]*Thought, error)
}
```

### SoyMemory Implementation

The default implementation uses PostgreSQL with pgvector:

```go
db, _ := sqlx.Connect("postgres", dsn)
memory, _ := cogito.NewSoyMemory(db)
```

### Semantic Search

Notes are automatically embedded when an Embedder is configured:

```go
cogito.SetEmbedder(cogito.NewOpenAIEmbedder(apiKey))

// Notes now have embeddings
thought.SetContent(ctx, "document", longText, "input")

// Search semantically
results, _ := memory.SearchNotes(ctx, queryEmbedding, 10)
for _, r := range results {
    fmt.Printf("%s: %s\n", r.Note.Key, r.Note.Content)
}
```

## Vector

Vectors are float32 slices used for embeddings:

```go
type Vector []float32

// Create from embedder
embedding, err := embedder.Embed(ctx, "search query")

// Use for search
results, _ := memory.SearchNotes(ctx, embedding, 10)
```

## Provider

Providers handle LLM communication:

```go
type Provider interface {
    Call(ctx context.Context, messages []zyn.Message, temperature float32) (*zyn.ProviderResponse, error)
    Name() string
}
```

### Resolution Hierarchy

1. Step-level: `.WithProvider(p)`
2. Context: `cogito.WithProvider(ctx, p)`
3. Global: `cogito.SetProvider(p)`

```go
// Global default
cogito.SetProvider(defaultProvider)

// Context override
ctx = cogito.WithProvider(ctx, specialProvider)

// Step override
decide := cogito.NewDecide("key", "question").WithProvider(customProvider)
```

## Embedder

Embedders generate vector embeddings:

```go
type Embedder interface {
    Embed(ctx context.Context, text string) ([]float32, error)
    Dimensions() int
}
```

OpenAI implementation included:

```go
embedder := cogito.NewOpenAIEmbedder(apiKey,
    cogito.WithEmbeddingModel(cogito.ModelTextEmbedding3Small, 1536),
)
cogito.SetEmbedder(embedder)
```

## Next Steps

- [Architecture](3.architecture.md) - System design deep dive
- [API Reference](../5.reference/1.api.md) - Complete API documentation
