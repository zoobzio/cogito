---
title: "Quickstart"
description: "Get started with cogito in 5 minutes"
author: "zoobzio"
published: 2024-12-01
updated: 2025-01-11
tags: [cogito, quickstart, tutorial]
---

# Quickstart

Get cogito running in your project in 5 minutes.

## Prerequisites

- Go 1.24 or later
- PostgreSQL 15+ with pgvector extension (for Memory persistence)
- An LLM provider (OpenAI, Anthropic, or compatible)

## Installation

```bash
go get github.com/zoobzio/cogito
```

## Basic Usage

### 1. Configure Provider and Embedder

```go
package main

import (
    "context"
    "github.com/zoobzio/cogito"
    "github.com/zoobzio/zyn/provider/openai"
)

func main() {
    // Set up LLM provider
    provider := openai.New(os.Getenv("OPENAI_API_KEY"))
    cogito.SetProvider(provider)

    // Set up embedder for semantic search
    embedder := cogito.NewOpenAIEmbedder(os.Getenv("OPENAI_API_KEY"))
    cogito.SetEmbedder(embedder)
}
```

### 2. Create a Memory Backend

```go
import (
    "github.com/jmoiron/sqlx"
    _ "github.com/lib/pq"
)

func setupMemory() (cogito.Memory, error) {
    db, err := sqlx.Connect("postgres", os.Getenv("DATABASE_URL"))
    if err != nil {
        return nil, err
    }

    return cogito.NewSoyMemory(db)
}
```

### 3. Create and Process a Thought

```go
func processTicket(ctx context.Context, memory cogito.Memory, ticketText string) error {
    // Create a thought
    thought, err := cogito.New(ctx, memory, "triage support ticket")
    if err != nil {
        return err
    }

    // Add initial context
    thought.SetContent(ctx, "ticket", ticketText, "input")

    // Build a pipeline
    pipeline := cogito.Sequence("ticket-triage",
        cogito.NewAnalyze[TicketData]("parse", "extract customer info and issue"),
        cogito.NewCategorize("category", "what type of issue?",
            []string{"billing", "technical", "account"}),
        cogito.NewDecide("escalate", "should this be escalated?").
            WithIntrospection(),
    )

    // Process
    result, err := pipeline.Process(ctx, thought)
    if err != nil {
        return err
    }

    // Read results
    category, _ := result.GetContent("category")
    escalate, _ := result.GetContent("escalate")

    fmt.Printf("Category: %s, Escalate: %s\n", category, escalate)
    return nil
}
```

## Complete Example

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"

    "github.com/jmoiron/sqlx"
    _ "github.com/lib/pq"
    "github.com/zoobzio/cogito"
    "github.com/zoobzio/zyn/provider/openai"
)

type TicketData struct {
    CustomerName string `json:"customer_name"`
    Issue        string `json:"issue"`
    Urgency      string `json:"urgency"`
}

func main() {
    ctx := context.Background()

    // Configure provider
    provider := openai.New(os.Getenv("OPENAI_API_KEY"))
    cogito.SetProvider(provider)

    // Configure embedder
    embedder := cogito.NewOpenAIEmbedder(os.Getenv("OPENAI_API_KEY"))
    cogito.SetEmbedder(embedder)

    // Set up memory
    db, err := sqlx.Connect("postgres", os.Getenv("DATABASE_URL"))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    memory, err := cogito.NewSoyMemory(db)
    if err != nil {
        log.Fatal(err)
    }

    // Create thought
    thought, err := cogito.New(ctx, memory, "analyse feedback")
    if err != nil {
        log.Fatal(err)
    }

    // Add input
    thought.SetContent(ctx, "feedback", "Your product is amazing!", "input")

    // Simple decision
    decide := cogito.NewDecide("positive", "is this positive feedback?")
    result, err := decide.Process(ctx, thought)
    if err != nil {
        log.Fatal(err)
    }

    positive, _ := result.GetContent("positive")
    fmt.Printf("Positive feedback: %s\n", positive)
}
```

## Next Steps

- [Core Concepts](2.concepts.md) - Understand Thought, Note, Memory
- [Architecture](3.architecture.md) - System design deep dive
- [API Reference](../5.reference/1.api.md) - Complete API documentation
